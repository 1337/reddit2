// Generated by CoffeeScript 1.7.1
(function() {
  var should,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  should = chai.should();

  describe('Infinite Scroll', function() {
    var $compile, $document, $rootScope, $timeout, docWindow, fakeWindow, origJq, scroller, scrollers, test, tests, _ref, _results;
    _ref = [void 0], $rootScope = _ref[0], $compile = _ref[1], docWindow = _ref[2], $document = _ref[3], $timeout = _ref[4], fakeWindow = _ref[5], origJq = _ref[6];
    beforeEach(function() {
      return module('infinite-scroll');
    });
    beforeEach(function() {
      return inject(function(_$rootScope_, _$compile_, _$window_, _$document_, _$timeout_) {
        var $window;
        $rootScope = _$rootScope_;
        $compile = _$compile_;
        $window = _$window_;
        $document = _$document_;
        $timeout = _$timeout_;
        fakeWindow = angular.element($window);
        sinon.stub(fakeWindow, 'last').returns(fakeWindow);
        origJq = angular.element;
        return angular.element = function() {
          var args, first;
          first = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (first === $window) {
            return fakeWindow;
          } else {
            return origJq.apply(null, [first].concat(__slice.call(args)));
          }
        };
      });
    });
    afterEach(function() {
      return angular.element = origJq;
    });
    tests = {
      'triggers on scrolling': function(scroller, container, injScope) {
        var el, isWindow, k, scope, v;
        el = angular.element(scroller);
        $document.append(el);
        if (container == null) {
          isWindow = true;
        }
        if (!isWindow) {
          container.height(1000);
        } else {
          sinon.stub(fakeWindow, 'height').returns(1000);
          container = fakeWindow;
        }
        scope = $rootScope.$new(true);
        for (k in injScope) {
          v = injScope[k];
          scope[k] = v;
        }
        scope.scroll = sinon.spy();
        $compile(el)(scope);
        $timeout.flush();
        container.scroll();
        scope.scroll.should.have.been.calledOnce;
        el.remove();
        return scope.$destroy();
      },
      'triggers immediately by default': function(scroller, container, injScope) {
        var el, isWindow, k, scope, v;
        el = angular.element(scroller);
        $document.append(el);
        if (container == null) {
          isWindow = true;
        }
        if (!isWindow) {
          container.height(1000);
        } else {
          sinon.stub(fakeWindow, 'height').returns(1000);
          container = fakeWindow;
        }
        scope = $rootScope.$new(true);
        for (k in injScope) {
          v = injScope[k];
          scope[k] = v;
        }
        scope.scroll = sinon.spy();
        $compile(el)(scope);
        $timeout.flush();
        scope.scroll.should.have.been.called;
        el.remove();
        return scope.$destroy();
      },
      'does not trigger immediately when infinite-scroll-immediate-check is false': function(scroller, container, injScope) {
        var el, isWindow, k, scope, v;
        el = angular.element(scroller);
        $document.append(el);
        if (container == null) {
          isWindow = true;
        }
        if (!isWindow) {
          container.height(1000);
        } else {
          sinon.stub(fakeWindow, 'height').returns(1000);
          container = fakeWindow;
        }
        scope = $rootScope.$new(true);
        for (k in injScope) {
          v = injScope[k];
          scope[k] = v;
        }
        scope.scroll = sinon.spy();
        $compile(el)(scope);
        $timeout.flush();
        scope.scroll.should.not.have.been.called;
        container.scroll();
        scope.scroll.should.have.been.called;
        el.remove();
        return scope.$destroy();
      },
      'does not trigger when disabled': function(scroller, container, injScope) {
        var el, isWindow, k, scope, v;
        el = angular.element(scroller);
        $document.append(el);
        if (container == null) {
          isWindow = true;
        }
        if (!isWindow) {
          container.height(1000);
        } else {
          sinon.stub(fakeWindow, 'height').returns(1000);
          container = fakeWindow;
        }
        scope = $rootScope.$new(true);
        for (k in injScope) {
          v = injScope[k];
          scope[k] = v;
        }
        scope.scroll = sinon.spy();
        scope.busy = true;
        $compile(el)(scope);
        scope.$digest();
        container.scroll();
        scope.scroll.should.not.have.been.called;
        el.remove();
        return scope.$destroy();
      },
      're-triggers after being re-enabled': function(scroller, container, injScope) {
        var el, isWindow, k, scope, v;
        el = angular.element(scroller);
        $document.append(el);
        if (container == null) {
          isWindow = true;
        }
        if (!isWindow) {
          container.height(1000);
        } else {
          sinon.stub(fakeWindow, 'height').returns(1000);
          container = fakeWindow;
        }
        scope = $rootScope.$new(true);
        for (k in injScope) {
          v = injScope[k];
          scope[k] = v;
        }
        scope.scroll = sinon.spy();
        scope.busy = true;
        $compile(el)(scope);
        scope.$digest();
        container.scroll();
        scope.scroll.should.not.have.been.called;
        scope.busy = false;
        scope.$digest();
        scope.scroll.should.have.been.called;
        el.remove();
        return scope.$destroy();
      },
      'only triggers when the container has been sufficiently scrolled down': function(scroller, container, injScope) {
        var el, isWindow, k, scope, v;
        el = angular.element(scroller);
        $document.append(el);
        if (container == null) {
          isWindow = true;
        }
        if (!isWindow) {
          container.height(1000);
          container.offset = function() {
            return {
              top: 7999,
              left: 0
            };
          };
        } else {
          sinon.stub(fakeWindow, 'height').returns(1000);
          sinon.stub(fakeWindow, 'scrollTop').returns(7998);
          container = fakeWindow;
        }
        scope = $rootScope.$new(true);
        for (k in injScope) {
          v = injScope[k];
          scope[k] = v;
        }
        scope.scroll = sinon.spy();
        $compile(el)(scope);
        scope.$digest();
        fakeWindow.scroll();
        scope.scroll.should.not.have.been.called;
        if (!isWindow) {
          el.pageYOffset = 800;
        } else {
          fakeWindow.scrollTop.returns(8000);
          container = fakeWindow;
        }
        container.scroll();
        scope.scroll.should.have.been.calledOnce;
        el.remove();
        return scope.$destroy();
      },
      'respects the infinite-scroll-distance attribute': function(scroller, container, injScope) {
        var el, isWindow, k, scope, v;
        el = angular.element(scroller);
        $document.append(el);
        if (container == null) {
          isWindow = true;
        }
        if (!isWindow) {
          container.height(1000);
          container.scrollTop = 3999;
        } else {
          sinon.stub(fakeWindow, 'height').returns(1000);
          sinon.stub(fakeWindow, 'scrollTop').returns(3998);
          container = fakeWindow;
        }
        scope = $rootScope.$new(true);
        for (k in injScope) {
          v = injScope[k];
          scope[k] = v;
        }
        scope.scroll = sinon.spy();
        $compile(el)(scope);
        scope.$digest();
        container.scroll();
        scope.scroll.should.not.have.been.called;
        if (!isWindow) {
          container.scrollTop = function() {
            return 4000;
          };
        } else {
          fakeWindow.scrollTop.returns(4000);
          container = fakeWindow;
        }
        container.scroll();
        scope.scroll.should.have.been.calledOnce;
        el.remove();
        return scope.$destroy();
      }
    };
    scrollers = {
      'triggers on scrolling': function() {
        return "<div infinite-scroll='scroll()' style='height: 1000px'\n  infinite-scroll-immediate-check='false'></div>";
      },
      'triggers immediately by default': function() {
        return "<div infinite-scroll='scroll()' style='height: 1000px'></div>";
      },
      'does not trigger immediately when infinite-scroll-immediate-check is false': function() {
        return "<div infinite-scroll='scroll()' infinite-scroll-distance='1'\n  infinite-scroll-immediate-check='false' style='height: 500px;'></div>";
      },
      'does not trigger when disabled': function() {
        return "<div infinite-scroll='scroll()' infinite-scroll-distance='1'\n  infinite-scroll-disabled='busy' style='height: 500px;'></div>";
      },
      're-triggers after being re-enabled': function() {
        return "<div infinite-scroll='scroll()' infinite-scroll-distance='1'\n  infinite-scroll-disabled='busy' style='height: 500px;'></div>";
      },
      'only triggers when the container has been sufficiently scrolled down': function() {
        return "<div infinite-scroll='scroll()'\n  infinite-scroll-distance='1' style='height: 10000px'></div>";
      },
      'respects the infinite-scroll-distance attribute': function() {
        return "<div infinite-scroll='scroll()' infinite-scroll-distance='5' style='height: 10000px;'></div>";
      }
    };
    _results = [];
    for (test in scrollers) {
      scroller = scrollers[test];
      _results.push((function(scroller, test) {
        var brokenTests;
        it("" + test, function() {
          return tests[test](scroller(), null, {});
        });
        brokenTests = ['respects the infinite-scroll-distance attribute', 'only triggers when the container has been sufficiently scrolled down'];
        if (__indexOf.call(brokenTests, test) >= 0) {
          return;
        }
        it("container: " + test, function() {
          var cont, sc;
          cont = angular.element("<div id=\"parent\" style=\"overflow: scroll;\"></div>");
          sc = angular.element(scroller());
          sc.attr("infinite-scroll-container", "elem");
          cont.append(sc);
          return tests[test](cont, cont, {
            elem: cont
          });
        });
        return it("parent: " + test, function() {
          var cont, sc;
          cont = angular.element("<div id=\"parent\" style=\"overflow: scroll;\"></div>");
          sc = angular.element(scroller());
          sc.attr("infinite-scroll-parent", "");
          cont.append(sc);
          return tests[test](cont, cont, {});
        });
      })(scroller, test));
    }
    return _results;
  });

}).call(this);
